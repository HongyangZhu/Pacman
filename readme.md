# Pacman
## 题意
* 初次运行服务器会告知程序的初始信息 选手的位置以及每回合执行时间的约束
* 每回合只能移动一步，只有5种选择，不动或者上下左右移动一格。
* 移动的优先级 大豆子>小豆子>战胜力量值比自己低的对手>空地
* 每个回合都会随机生成大小豆子，并随机放置在空格上，每次生成4个小豆子，并按照一定概率（10%）生成一个大豆子
```java
public class JavaPlayer {
  /* 该接口在游戏中只会被调用一次,用于告知选手程序游戏的初始信息。
   *
   * @param position 选手的位置
   * @param timeLimit 每回合执行的时间约束，单位毫秒
   * @throws Exception
   */
  public void ready(int position, int timeLimit) throws Exception {
      
  }

  /**
   * 该接口在游戏中每回合都会被调用一次，用于告知选手程序当前局面，选手程序自行决定行动。
   * 注意：如果board数组中有值超过10000，代表它有无敌光环，strength也是。
   *
   * @param board    局面的位置列表，假设a行b列(0<=a,b<21)，那么对应的值是21*a+b，当前位置为ghost为-1，为空表示-2
   *                 ，为-3表示大豆子,为-4表示小豆子,为-5、-6、-7表示不同的障碍，
   *                 其余>=0 为该位置的pacman所代表的力量（包括一个自己）
   * @param strength 当前的力量，由服务器传回来
   * @return 方向0代表不动，1,2,3,4 分别代表左、上、右、下，其他输入皆非法
   * @throws Exception
   */
  public int run(int[] board, int strength) throws Exception {
      
  }
}
```
## 胜负规则
* 如果玩家程序执行异常，或超时，或撞到障碍物，该名玩家判定为死亡。
* 如果玩家在没有无敌光环（吃到大豆子时10个回合内），碰到ghost时判定为死亡。
* 如果玩家在战斗中牺牲，判定为死亡。
* 比赛运行到只剩最后一个玩家，或者超过预定回合数（500）时结束比赛，根据力量值判定输赢。

## 思路
* 优先选择吃大豆子，小豆子。找到离自己当前位置最佳的豆子。
  可能还需要考虑其他玩家的位置，选择一条最有可能吃到的豆子路线进行行进。
  * 当没有吃过大豆子时需要躲避幽灵。
  * 躲避其他比自己力量值高的玩家。<font color="red">是否能取得其他玩家的力量值信息？</font>
  
* 因为每个回合都会生成新的豆子，需要重新规划路线。
* 地图的边界是互通的，并且场地是中心对称的，每四分之一的场地都是相同的（包括道具，障碍，玩家的初始位置）
* 每次进行路线规划的算法是需要考虑到执行时间的约束，要在时间内完成选择。
当时间内没有结果时，应该考虑暂停算法，并将结果保存以便于下次算法的执行。
  


## 算法选择
dfs(深度优先搜索)？bfs(宽度/广度优先搜索)？
>bfs是用来搜索最短径路的解法是比较合适的
比如求最少步数的解，最少交换次数的解，最快走出迷宫等等，因为bfs搜索过程中遇到的第一个解一定是离最初位置最近的，所以遇到第一个解，一定就是最优解，此时搜索算法可以终止
而如果用dfs，会搜一些其他的位置，需要花相对比较多的时间，需要搜很多次，然后如果找到还不一定是最优解，还要记录这次找的位置，与之后找到的答案进行比较，看看谁才是最优解，这样就比较麻烦

