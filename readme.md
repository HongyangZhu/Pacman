# Pacman
## 题意
* 初次运行服务器会告知程序的初始信息 选手的位置以及每回合执行时间的约束
* 每回合只能移动一步，只有5种选择，不动或者上下左右移动一格。
* 移动的优先级 大豆子>小豆子>战胜力量值比自己低的对手>空地
* 每个回合都会随机生成大小豆子，并随机放置在空格上，每次生成4个小豆子，并按照一定概率（10%）生成一个大豆子
* 服务器运行时内存会加载参赛者对象，每回合调用对应的方法，所以可以自己定义变量，私有方法等，用来辅助这两个方法

```java
public class JavaPlayer {
  /* 该接口在游戏中只会被调用一次,用于告知选手程序游戏的初始信息。
   *
   * @param position 选手的位置
   * @param timeLimit 每回合执行的时间约束，单位毫秒
   * @throws Exception
   */
  public void ready(int position, int timeLimit) throws Exception {
      
  }

  /**
   * 该接口在游戏中每回合都会被调用一次，用于告知选手程序当前局面，选手程序自行决定行动。
   * 注意：如果board数组中有值超过10000，代表它有无敌光环，strength也是。
   *
   * @param board    局面的位置列表，假设a行b列(0<=a,b<21)，那么对应的值是21*a+b，当前位置为ghost为-1，为空表示-2
   *                 ，为-3表示大豆子,为-4表示小豆子,为-5、-6、-7表示不同的障碍，
   *                 其余>=0 为该位置的pacman所代表的力量（包括一个自己）
   * @param strength 当前的力量，由服务器传回来
   * @return 方向0代表不动，1,2,3,4 分别代表左、上、右、下，其他输入皆非法
   * @throws Exception
   */
  public int run(int[] board, int strength) throws Exception {
      
  }
}
```
## 胜负规则
* 如果玩家程序执行异常，或超时，或撞到障碍物，该名玩家判定为死亡。
* 如果玩家在没有无敌光环（吃到大豆子时10个回合内），碰到ghost时判定为死亡。
* 如果玩家在战斗中牺牲，判定为死亡。
* 比赛运行到只剩最后一个玩家，或者超过预定回合数（500）时结束比赛，根据力量值判定输赢。

## 思路
* 优先选择吃大豆子，小豆子。找到离自己当前位置最佳的豆子。
  可能还需要考虑其他玩家的位置，选择一条最有可能吃到的豆子路线进行行进。
  * 当没有吃过大豆子时需要躲避幽灵。
  * 躲避其他比自己力量值高的玩家。<font color="red">是否能取得其他玩家的力量值信息？</font>
  
* 因为每个回合都会生成新的豆子，需要重新规划路线。
* 每次进行路线规划的算法是需要考虑到执行时间的约束，要在时间内完成选择。
当时间内没有结果时，应该考虑暂停算法，并将结果保存以便于下次算法的执行。
  * 地图的边界是互通的，并且场地是中心对称的，每四分之一的场地都是相同的（包括道具，障碍，玩家的初始位置）
  * 可以优化算法
  


## 最短路径算法选择
**bfs(宽度/广度优先搜索)**
>bfs是用来搜索最短径路的解法是比较合适的
比如求最少步数的解，最少交换次数的解，最快走出迷宫等等，因为bfs搜索过程中遇到的第一个解一定是离最初位置最近的，所以遇到第一个解，一定就是最优解，此时搜索算法可以终止
而如果用dfs，会搜一些其他的位置，需要花相对比较多的时间，需要搜很多次，然后如果找到还不一定是最优解，还要记录这次找的位置，与之后找到的答案进行比较，看看谁才是最优解，这样就比较麻烦

**优先队列**
>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。

### <b><font color="red" >A*算法</font></b>
>1968年，的一篇论文，“P. E. Hart, N. J. Nilsson, and B. Raphael. A formal basis for the heuristic determination of minimum cost paths in graphs. IEEE Trans. Syst. Sci. and Cybernetics, SSC-4(2):100-107, 1968”。从此，一种精巧、高效的算法------A*算法横空出世了，并在相关领域得到了广泛的应用。
A*搜寻算法俗称A星算法。这是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或线上游戏的BOT的移动计算上。

A*算法是在最短路径类型的题目中出现的，通常同时出现的解决方法还有Dijkstra算法，BFS算法，DFS算法。在盲目搜索中使用后三者的平率较高，但是在时间复杂度较低的启发式搜索中A*算法能够具有目的性，选择性的朝向目标前进。

A算法是启发式算法重要的一种，主要是用于在两点之间选择一个最优路径，而A的实现也是通过一个估值函数

#### F=G+H
* G表示该点到起始点位所需要的代价
* H表示该点到终点的曼哈顿距离。
* F就是G和H的总和，而最优路径也就是选择最小的F值，进行下一步移动（后边会做详细介绍）
